---
title: "Generating BreweryDB API Functions"
output: html_notebook
---

### Introduction

<br>

An API or Application Program Interface is a standard tool for creating software applications. There are many well-known APIs such as the Google APIs backing Docs, Drive, Calendar, Assistant and [lots more](https://developers.google.com/apis-explorer/). The purpose of this article is to explain how to automatically generate a package containing human-readable functions which utilize the [BreweryDB API](https://www.brewerydb.com/developers). This will allow us to search the BreweryDB database and find all sorts of data on beer and breweries!

<br>

Generally, the API documentation provided by websites is automatically generated in HTML to product documenation pages. We will in a way reverse engineer this process, scraping HTML documentation and pulling out the API methods and objects. A method is an action while an object is the thing that a method acts on. 

<br>

![<br><i>Example of HTML Documentation for an API</i>](images/exampleAPIdoc.png)

<br>

### API Calls

<br>

To make an API call, we use the [httr package](https://cran.r-project.org/web/packages/httr/vignettes/quickstart.html) to perform the request. We will need to specify the API method (GET, POST, PUT and DELETE) and the endpoint URL where we will send our request. Additionally, each API has special ways of giving permission for you to access their API. To make API calls to the BreweryDB API, we need to obtain a "key" and attach it as a query parameter to our call. To obtain your own, follow the [developer instructions](https://www.brewerydb.com/developers).

<br>

Here's code I use to check my authentication when working with APIs. 

```{r message=FALSE, warning=FALSE}

  checkAuthentication <- function(){
  
    suppressPackageStartupMessages(require(httr))
    suppressPackageStartupMessages(require(jsonlite))
    suppressPackageStartupMessages(require(tidyverse))
    
    ops <- Sys.getenv()
    requiredOptions <- c("brewerydbKey")
    
    for(option in requiredOptions){
      if(Sys.getenv(option) == ''){
        stop(paste0('Required option ', option, ' has not been set! Set its value using Sys.setenv(', option, ' = "{', option, 'Value}").'))
      }
    }
  }

  try({checkAuthentication()})

```

<br>

I have a file which is placed in my .gitignore which sets my API credentials for a session but isn't inadvertently posted to GitHub!

```{r}

  source('../../apiCredentials.R')

```

<br>

And here's code to make an API call using BrewerDB's syntax. I've added some features we'll need later.

```{r}

  # This function makes a BreweryDB API request.
  makeRequest <- function(endpoint, verb, params = NULL){
  
    suppressPackageStartupMessages(require(httr))
    suppressPackageStartupMessages(require(tidyverse))
    suppressPackageStartupMessages(require(magrittr))
    
    checkAuthentication()
    
    baseUrl <- 'https://sandbox-api.brewerydb.com/v2'
    
    endpoint %<>% paste0('/?key=', Sys.getenv('brewerydbKey'))
  
    if(length(params) > 0) endpoint %<>% paste0('&', URLencode(paste(paste(names(params), as.character(params), sep = '='), collapse = '&')))
  
    request <- paste0(verb, '("', baseUrl, endpoint, '", accept_json())')
  
    eval(parse(text = paste0('response <- ', request)))
    
    if(response$status_code < 300){
      return(content(response))
    }else{
      stop(content(response))
    }
  }

  # Testing it out.
  sampleRequest <- makeRequest('/beer/WHQisc', 'GET')
  print(sampleRequest)
```

<br>

As you can see, the return type is JSON formatted. We can use the [jsonlite package](https://cran.r-project.org/web/packages/jsonlite/vignettes/json-aaquickstart.html) to convert this into something more manageable.

```{r}

  # This function consistently flattens a json list into a dataframe.
flattenJsonList <- function(jsonList){
  
  require(dplyr)
  require(jsonlite)
  
  # If jsonList is not a named list, make it one.
  if(length(names(jsonList[[1]])) == 0){ 
    
    jsonList <- list(jsonList)
    
  }
  
  for(item in jsonList){
    
    item <- data.frame(item, stringsAsFactors = F)
   
    if(!exists('df', inherits = FALSE)){
      df <- flatten(item) %>% as.data.frame()
    }else{
      df <- bind_rows(df, flatten(item) %>% as.data.frame())
    }
  }
  
  return(df)
}

  print(flattenJsonList(sampleRequest$data) %>% as.data.frame())

```

### API Documentation -> R Functions

<br>

For the example above, the documenation is all about Beer which I'll call our object. Clicking around on the endpoint pages, we see that documentation pages can be used as object names. The current page is "beer-index", and is followed below by "beer-adjunct" and "beer-brewery". Other examples include "brewery-index" and "brewery-beer", so it makes sense to scrape a page to correspond to our object name.

```{r}

  suppressPackageStartupMessages(require(tidyverse))

  # Eventually we'd like to scrape the whole site so let's prepare.
  pages = c('beer-index', 'beer-adjunct', 'beer-brewery')

  for(page in pages){ 
    
     object <- page %>% str_replace('-', ' ') %>% str_to_title() %>% str_replace(' ', '') %>% str_replace('Index', '')
    
     print(object)
  }
```

<br>

The beer-index page lists API methods for interacting with Beer objects. These five main sections spell out a logical method for generating function names.

<br>

| Documentation        | Method| Endpoint URL  | R Function        | What it does                    |
| :------------------: |:-----:| :------------:|:-----------------:|:-------------------------------:|
| GET: /beers          | GET   | /beers        | getEveryBeer(...) | Lists every beer                |
| GET: /beer/:beerId   | GET   | /beer/:beerId | getBeer(...)      | Gets details on a specific beer |
| POST: /beers         | POST  | /beers        | createBeer(...)   | Creates a new beer              |
| PUT: /beer/:beerId   | PUT   | /beer/:beerId | modifyBeer(...)   | Modifies a specific beer        |
| DELETE: /beer/:beerId| DELETE| /beer/:beerId | deleteBeer(...)   | Deletes a specific beer         |

<br>

So how do we go about generating functions? [The Rvest Package](https://github.com/tidyverse/rvest/blob/master/README.md)!

<br>

### Scraping HTML API Documentation

<br>

Once we have identified where on the screen are the API methods and endpoints, we need to pull that information into R. Rvest allows us to search a static web page for html nodes and attributes. I find it easiest to use a tool like [Google Chrome's Selector Gadget](https://chrome.google.com/webstore/search/selector%20gadget) to identify the specific HTML elements to scrape.

![<br><i>Selector Gadget in the Chrome Web Store</i>](images/selectorGadget.png)

<br>

Let's get scraping! It turns out that our method/endpoint texts correspond to "h3 span" elements. They will need to be split on the colon right after the api method text. Eg. "GET:" /beers" becomes apiMethod "GET" and endpoint "/beers".

```{r}

  suppressPackageStartupMessages(require(rvest))
  suppressPackageStartupMessages(require(magrittr))

  functionsUrl <- 'https://www.brewerydb.com/developers/docs/endpoint/'
  
  # Eventually we'll expand this to all pages.
  for(page in 'beer-index'){ 
    
    html <- read_html(paste0(functionsUrl, page))
  
    # Each method becomes a function.
    apiMethods <- html %>% html_nodes('h3 span') %>% rvest::html_text()
    
    methodsAndEndpoints <- NULL
    for(i in 1:length(apiMethods)){
      
      apiMethodText <- apiMethods[[i]]
      
      # Grab api method (GET, POST, PUT, DELETE)
      apiMethod <- str_sub(apiMethodText, 1, apiMethodText %>% str_locate(':') %>% extract2(1) - 1)
      
      # Grab endpoint for request.
      endpoint <- apiMethodText %>% str_sub(apiMethodText %>% str_locate(':') %>% extract2(1) + 2, nchar(apiMethodText))
      
      methodsAndEndpoints <- bind_rows(methodsAndEndpoints, tibble(Method = apiMethod, Endpoint = endpoint))
    }
    
    print(methodsAndEndpoints)
  }
```

<br>

Just for funzies, let's run it on some more pages to make sure the documentation is consistent.

<br>

```{r}

  pages <- c('beer-index', 'beer-adjunct', 'beer-brewery')

  # Eventually we'll expand this to all pages.
  for(page in pages){ 
    
    html <- read_html(paste0(functionsUrl, page))
  
    # Each method becomes a function.
    apiMethods <- html %>% html_nodes('h3 span') %>% rvest::html_text()
    
    methodsAndEndpoints <- NULL
    for(i in 1:length(apiMethods)){
      
      apiMethodText <- apiMethods[[i]]
      
      # Grab api method (GET, POST, PUT, DELETE)
      apiMethod <- str_sub(apiMethodText, 1, apiMethodText %>% str_locate(':') %>% extract2(1) - 1)
      
      # Grab endpoint for request.
      endpoint <- apiMethodText %>% str_sub(apiMethodText %>% str_locate(':') %>% extract2(1) + 2, nchar(apiMethodText))
      
      methodsAndEndpoints <- bind_rows(methodsAndEndpoints, tibble(Method = apiMethod, Endpoint = endpoint))
    }
    
    print(page)
    print(methodsAndEndpoints)
  }
```

<br>

Now we're cooking. While we're at it, could we scrape the page name of each documentation page we will want functions for? It turns out that each of those page labels are "li a" elements on the documentation page. Finding those elements and grabbing their 'href' attribute will give us each page URL we'll need.

```{r}

  # This function returns all api endpoint pages.
  getAllAPIpages <- function(){
    
    html <- read_html(paste0(functionsUrl))
    
    pages <- html %>% html_nodes('li a') %>% html_attr('href')
    
    pages <- pages[pages %>% str_which('/developers/docs/endpoint/')] %>% str_replace_all('/developers/docs/endpoint/', '')
    
    return(pages)
  }

  getAllAPIpages()
```

<br>

So how do we translate the api method and endpoint into a function? Let's start by generating the easiest function: getEveryBeer(...). 

### Generating .R Files

<br>

The [readr package](https://readr.tidyverse.org) has a very handy function called write_lines(x, path, append) which will write text to a given file. If we're clever with it we can generate a .R file with functions on the fly. write_lines will also generate any files that don't already exist.

<br>

Let's see an example.
```{r}

  functionText <- paste0('\n\treturn(text)\n\n}')

  write_lines('helloWorld <- function(text = "Hello World!"){\n', 'helloWorld.R')
  write_lines('\treturn(text)\n', 'helloWorld.R', append = T)
  write_lines('}', 'helloWorld.R', append = T)
  
  source('helloWorld.R')
  
  print(helloWorld)
  
  print(helloWorld())
  
  file.remove('helloWorld.R')
```

<br>

So how do we generate getEveryBeer(...)? The general structure is easy but the API method has many parameters we need to make it fully functional. We can scrape those using Rvest too. It turns out using Selector Gadget that each table of parameters has an element id of "param_0", "param_1", one for each API method or function we will generate.

<br>

```{r}

  html <- read_html(paste0(functionsUrl, 'beer-index'))

  # Each method becomes a function.
  apiMethods <- html %>% html_nodes('h3 span') %>% rvest::html_text()

  for(i in 1:length(apiMethods)){
    # Grab function parameters. //*[(@id = "params_0")]
        params <- html %>% rvest::html_nodes(xpath = paste0('////*[(@id = "params_', i-1, '")]')) %>% html_children() %>% extract2(2)
        
        ifelse(params %>% html_name() == 'table', params %<>% html_table() %>% mutate_all(str_squish), params <- NA)
        
        ifelse(!is.na(params), print(params %>% mutate_all(function(x) str_sub(x, start = 1, end = 30)) %>% head()), print(params))
  }
```

<br>

And now we're ready to make our function. We make a variable called functionText to contain the string of our function which we will then use write_lines on to create the text in our .R file. Let's start putting it together.

<br>

```{r message=FALSE, warning=FALSE}

  functionsUrl <- 'https://www.brewerydb.com/developers/docs/endpoint/'

  # Eventually we'd like to scrape the whole site so lets prepare.
  pages <- c('beer-index')

  for(page in pages){ 
    
     object <- page %>% str_replace('-', ' ') %>% str_to_title() %>% str_replace(' ', '') %>% str_replace('Index', '')
 
    # Name the file "Beer.R"
    filepath <- paste0(object, ".R")
      
    # Instantiate the .R file.
    write_lines('', filepath)
       
    html <- read_html(paste0(functionsUrl, page))
  
    # Each method becomes a function.
    apiMethods <- html %>% html_nodes('h3 span') %>% rvest::html_text()
  
    for(i in 1:length(apiMethods)){
      
      apiMethodText <- apiMethods[[i]]
      
      # Grab API method (GET, POST, PUT, DELETE)
      apiMethod <- str_sub(apiMethodText, 1, apiMethodText %>% str_locate(':') %>% extract2(1) - 1)
      
      # Grab endpoint for request.
      endpoint <- apiMethodText %>% str_sub(apiMethodText %>% str_locate(':') %>% extract2(1) + 2, nchar(apiMethodText))
      
      # Grab function parameters. //*[(@id = "params_0")], etc.
          params <- html %>% rvest::html_nodes(xpath = paste0('////*[(@id = "params_', i-1, '")]')) %>% html_children() %>% extract2(2)
          
          ifelse(params %>% html_name() == 'table', params %<>% html_table() %>% mutate_all(str_squish), params <- NA)
          
  # Replace API methods with human-readable functions. getEvery(object), get(object), create(object), update(object), delete(object).
        functionName <- c('get', 'create', 'update', 'delete')[which(c('GET', 'POST', 'PUT', 'DELETE') == apiMethod)]
        if(endpoint %>% str_sub(-2, -1) != 'Id' & apiMethod != 'POST') functionName %<>% paste0('Every')
        functionName %<>% paste0(object)
  
      # Start the function text that will contain the string of our functions to be written to our .R file.
      functionText <- paste0(functionName, ' <- function(')
      
      # Add params to functions.
      if(!is.na(params)){
        for(i in 1:nrow(params)){
       
          param <- params$Parameter[[i]] %>% str_replace(' Required', '')
       
          functionText %<>% paste0(ifelse(i == 1, param, paste0(', ', param)))
        }
      }     
         
      functionText %<>% paste0('){\n\n')
      
      functionText %<>% paste0('\tparams <- as.list(environment())\n\tparams <- params[params != ""]\n\n')
      
      functionText %<>% paste0('\tendpoint <- "', endpoint, '"\n\n')
      
      
      # Create the API call.
      functionText %<>% paste0('\treturnData <- makeRequest(endpoint, "', apiMethod, '", params)\n\n')
  
      functionText %<>% paste0('\tflattenJsonList(returnData$data)\n\n}\n\n')
      
      write_lines(functionText, filepath, append = T)
    }
   
    source(filepath)
      
    print(getEveryBeer(name = "Dragon's Milk"))
    file.remove(filepath)
  }
```
